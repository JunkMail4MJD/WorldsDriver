#pragma config(Motor,   motor1,        wristMotor,    tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,   motor2,        rightMotor,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Sensor,  port5,  			 gyro,          sensorVexIQ_Gyro)
#pragma config(Motor,   motor6,        leftMotor,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,   motor7,        armMotor,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,   motor12,       clawMotor,     tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//Global Variable declarations
task displayMyMotorPositions();
//void moveToStartingPosition();
//void moveToNeutralPosition();
//void moveMechanism( int targetClawPosition, int targetWristPosition, int targetArmPosition, int powerLevel);
//void executeBlockGrabbingStep( int blockGrabbingStep);
//void executeBlockStackingStep( int blockStackingStep);
//void putBlocksDown();
//void grabBlocks();
//void liftBlocksUp();
//void loadBlocks();
//void unloadBlocks();
//void moveToStackDrivingPosition();
//void moveToStackAimingPosition();


//int const 	MAX_BLOCK_LOADING_STEPS = 3, 			MAX_BLOCK_STACKING_STEPS = 3;
//float const BLOCK_CLEARANCE_DISTANCE = 4, 		STACK_CLEARANCE_DISTANCE = 8;
//float const CLAW_GRABBING = 40, WRIST_GRABBING = -144, 	ARM_GRABBING = 135;
//float const CLAW_LOADING = 80, 	WRIST_LOADING = -3660, 	ARM_LOADING = -325;
//float const 										WRIST_LIFTING = -1830, 	ARM_LIFTING = -500;
//float const CLAW_NEUTRAL = 90,	CLAW_WHEEL_LIMIT = 68, 	ARM_DRIVING_STACK = -500, 			ARM_AIMING_STACK = -1000;
//float const 																						ARM_UNLOAD_STACK = -1150;

float globalArmPosition = 0, globalClawPosition = 0, globalWristPosition = 0;

//bool	globalBlocksInClaw = false;

task main() {

	/*
	using resetMotorEncoder is best. it allows you to repeated go back to a specific motor position for arm, wrist, stacker and claw movements.

	WRISTMOTOR - moves the wrist up  and positive moves the wrist down
	0 degrees is the starting position
	-3660 degrees makes the wrist completely aligned with the stacking bay


	ARM MOTOR(s) negative moves the arm downward positive moves the arm upwards

	0 degrees is approximately flat
	xxx degrees is a good start at trying to have block slide into the stacking unit
	xxx degrees is having the stacking unit fully vertical



	STACKER MOTOR positive opens the stacker
	xxx degrees is fully closed on the stacker unit
	xxx degrees is clamped down on blocks in the stacker
	xxx degrees is just wide enough to allow blocks to slide into the stacker

	clawMotor positive degrees opens the claw and negative degrees closes the claw
	XX degrees looks roughly large enough to grab a block
	XX degrees is as wide as it can go to stay within the robot's wheel cavity
	XX degrees is wide enough to let the blocks slide into the stacker
	*/



//	int powerLevel = 100;
	int leftMotorSpeed, rightMotorSpeed, wristMotorSpeed, armMotorSpeed, stickAValue, stickBValue, stickCValue, stickDValue;
//	int blockGrabbingStep = 0, blockStackingStep = 0;

	resetMotorEncoder(armMotor);
	resetMotorEncoder(clawMotor);
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(wristMotor);

	resetGyro(gyro);
	startGyroCalibration(gyro, gyroCalibrateSamples2048);
	eraseDisplay();
	getGyroCalibrationFlag(gyro);
	displayString(3, "calibrating gyro");
	wait1Msec(500);
	eraseDisplay();

	startTask(displayMyMotorPositions);


	while (true ){


		/***************************************************************************************************************/
		//Joystick Control:

		stickAValue  = getJoystickValue(ChA);
		if ((stickAValue <= 15) && (stickAValue >= -15) ) stickAValue = 0;

		stickBValue  = getJoystickValue(ChB);
		if ((stickBValue <= 15) && (stickBValue >= -15) ) stickBValue = 0;

		if (stickBValue >=0 ) 	 	stickBValue = (stickBValue / 10) * (stickBValue / 10) * 2;
		else stickBValue = 		- (stickBValue / 10) * (stickBValue / 10) * 2;



		leftMotorSpeed = stickAValue - stickBValue;
		rightMotorSpeed = stickAValue + stickBValue;

		if ( leftMotorSpeed > 100) leftMotorSpeed = 100;
		if ( leftMotorSpeed < -100) leftMotorSpeed = -100;

		if ( rightMotorSpeed > 100) rightMotorSpeed = 100;
		if ( rightMotorSpeed < -100) rightMotorSpeed = -100;

		if (leftMotorSpeed >=0 ) 	 	leftMotorSpeed = (leftMotorSpeed / 10) * (leftMotorSpeed / 10);
		else leftMotorSpeed = 		- (leftMotorSpeed / 10) * (leftMotorSpeed / 10);
		if (rightMotorSpeed >=0 ) 	rightMotorSpeed = (rightMotorSpeed / 10) * (rightMotorSpeed / 10);
		else rightMotorSpeed = 		- (rightMotorSpeed / 10) * (rightMotorSpeed / 10);

		setMotorSpeed(leftMotor, leftMotorSpeed);
		setMotorSpeed(rightMotor, rightMotorSpeed);


		/***************************************************************************************************************/
		//WRIST MOTOR
		stickDValue		= getJoystickValue(ChD);
		if ((stickDValue <= 15) && (stickDValue >= -15) ) stickDValue = 0;

		wristMotorSpeed = stickDValue;

		if (wristMotorSpeed >=0 ) 	 	wristMotorSpeed = (wristMotorSpeed / 10) * (wristMotorSpeed / 10);
		else wristMotorSpeed = 		- (wristMotorSpeed / 10) * (wristMotorSpeed / 10);


		setMotorSpeed(wristMotor, wristMotorSpeed );


		/***************************************************************************************************************/
		//ARM MOTOR
		stickCValue		= getJoystickValue(ChC);
		if ((stickCValue <= 15) && (stickCValue >= -15) ) stickCValue = 0;

		armMotorSpeed = stickCValue;

		if (armMotorSpeed >=0 ) 	 	armMotorSpeed = (armMotorSpeed / 10) * (armMotorSpeed / 10);
		else armMotorSpeed = 		- (armMotorSpeed / 10) * (armMotorSpeed / 10);

		setMotorSpeed(armMotor, armMotorSpeed );



		/***************************************************************************************************************/
		//CLAW MOTOR
		if(getJoystickValue(BtnLUp) > 0)   {  //OPEN
			globalClawPosition+=2;
			//			if (globalClawPosition > 89) globalClawPosition = 90;
			//			setMotorTarget(clawMotor, globalClawPosition, 25);
			setMotorSpeed(clawMotor, 70);
		}
		else if(getJoystickValue(BtnLDown) > 0)   {  //CLOSE
			globalClawPosition-=2;
			//			if (globalClawPosition < 40) globalClawPosition = 40;
			//			setMotorTarget(clawMotor, globalClawPosition, 25);
			setMotorSpeed(clawMotor, -70);
		}
		else {
			setMotorSpeed(clawMotor, 0);
		}


		/***************************************************************************************************************/

		//Block grabbing and Loading Process
		/*		if(getJoystickValue(BtnEUp) > 0)   {  //UP
		executeBlockGrabbingStep( blockGrabbingStep);
		blockGrabbingStep++;
		if ( blockGrabbingStep >= MAX_BLOCK_LOADING_STEPS) blockGrabbingStep = 0;
		wait1Msec(50);
		}
		if(getJoystickValue(BtnEDown) > 0)   {  //DOWN
		if (globalBlocksInClaw) {
		putBlocksDown();
		}
		blockGrabbingStep = 0;
		moveToNeutralPosition();
		wait1Msec(50);
		}
		*/
		/***************************************************************************************************************/
		//Block Stacking Process
		/*		if(getJoystickValue(BtnFUp) > 0)   {  //UP
		executeBlockStackingStep( blockStackingStep);
		blockStackingStep++;
		if ( blockStackingStep >= MAX_BLOCK_STACKING_STEPS) blockStackingStep = 0;
		wait1Msec(50);
		}

		//Return to Starting position
		if(getJoystickValue(BtnFDown) > 0) {
		moveToStartingPosition();
		blockStackingStep = 0;
		blockGrabbingStep = 0;
		wait1Msec(50);
		}
		*/
	}

}


task displayMyMotorPositions(){

	float clawEncoderValue, wristEncoderValue, armEncoderValue, calibratedGyroDegrees, calibratedGyroHeading;



	while(true) {

		calibratedGyroDegrees = getGyroDegreesFloat(gyro);
		calibratedGyroHeading = getGyroHeadingFloat(gyro);

		clawEncoderValue 		= getMotorEncoder(clawMotor);
		wristEncoderValue 	= getMotorEncoder(wristMotor);
		armEncoderValue 		= getMotorEncoder(armMotor);

		eraseDisplay();
		displayString(0, "claw:  %f3", clawEncoderValue);
		displayString(1, "wrist: %f3", wristEncoderValue);
		displayString(2, "arm:   %f3", armEncoderValue);
		displayString(4, "d: %f3  h: %f3", calibratedGyroDegrees, calibratedGyroHeading);

		wait1Msec(1000);
	}
}

/*
void moveMechanism( int targetClawPosition, int targetWristPosition, int targetArmPosition, int powerLevel) {

	float clawProgress, wristProgress, armProgress;
	int progressDifference;

	setMotorTarget(armMotor,  	 targetArmPosition, 		powerLevel);
	setMotorTarget(clawMotor,    targetClawPosition, 		powerLevel);
	setMotorTarget(wristMotor,   targetWristPosition , 	powerLevel);

	bool motorsMoving = true, clawFinished = false, armFinished = false, wristFinished = false;

	while(motorsMoving) {

		//prevent divide by zero errors... we end up waiting longer when our target is 0

		if (targetClawPosition != 0 )		clawProgress = 		getMotorEncoder(clawMotor) / targetClawPosition;
		else 	{
			progressDifference = abs(getMotorEncoder(clawMotor) - targetClawPosition);
			if (progressDifference < 5) clawProgress = 1;
			else clawProgress = .5;
		}


		if (targetWristPosition != 0 )	wristProgress = 	getMotorEncoder(wristMotor) / targetWristPosition;
		else 	{
			progressDifference = abs(getMotorEncoder(wristMotor) - targetWristPosition);
			if (progressDifference < 5) wristProgress = 1;
			else wristProgress = .5;
		}

		if (targetArmPosition != 0 )		armProgress = 		getMotorEncoder(armMotor) / targetArmPosition;
		else 	{
			progressDifference = abs(getMotorEncoder(armMotor) - targetArmPosition);
			if (progressDifference < 5) armProgress = 1;
			else armProgress = .5;
		}

		if ( (clawProgress    > .85) && (clawProgress    < 1.15) ) clawFinished = true;
		if ( (armProgress     > .92) && (armProgress     < 1.08) ) armFinished = true;
		if ( (wristProgress   > .92) && (wristProgress   < 1.08) ) wristFinished = true;

		if ( clawFinished && armFinished && wristFinished )
			motorsMoving = false;
	}

	globalClawPosition = targetClawPosition;
	globalWristPosition = targetWristPosition;
	globalArmPosition = targetArmPosition;

}
*/

/*
void driveStraight( float mmToDrive, int speed) {


	float degreesToDrive = mmToDrive / 200 * 360;
	float leftProgress, rightProgress;
	int progressDifference;


	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	setMotorTarget(leftMotor,  degreesToDrive, speed);
	setMotorTarget(rightMotor, degreesToDrive, speed);

	bool motorsMoving = true, leftFinished = false, rightFinished = false;

	while(motorsMoving) {

		//prevent divide by zero errors... we end up waiting longer when our target is 0

		if (degreesToDrive != 0 ) {
			leftProgress = 		getMotorEncoder(leftMotor)  / degreesToDrive;
			rightProgress = 	getMotorEncoder(rightMotor) / degreesToDrive;
		}
		else 	{
			progressDifference = abs(getMotorEncoder(leftMotor) - degreesToDrive);
			if (progressDifference < 5) leftProgress = 1;
			else leftProgress = .5;

			progressDifference = abs(getMotorEncoder(rightMotor) - degreesToDrive);
			if (progressDifference < 5) rightProgress = 1;
			else rightProgress = .5;
		}


		if ( (rightProgress    > .95) && (rightProgress    < 1.05) ) rightFinished = true;
		if ( (leftProgress     > .95) && (leftProgress     < 1.05) ) leftFinished = true;

		if ( leftFinished && rightFinished )
			motorsMoving = false;
	}


}
*/


/*
void executeBlockGrabbingStep( int blockGrabbingStep) {

	switch (blockGrabbingStep) {
	case 0:
		grabBlocks();
		break;

	case 1:
		liftBlocksUp();
		break;

	case 2:
		loadBlocks();
		break;
	}

}
*/

/*
void executeBlockStackingStep( int blockStackingStep) {

	switch (blockStackingStep) {

	case 0:
		moveToStackDrivingPosition();
		break;


	case 1:
		moveToStackAimingPosition();
		break;

	case 2:
		unloadBlocks();
		break;
	}

}
*/

/*
void 	moveToStartingPosition() {

	//	Position for being able to Drive and clear block height
	int powerLevel = 75, armPosition, wristPosition, clawPosition = 0;


	//if the wrist if fully extended then get that next. It will hit the ground otherwise.
	if (wristPosition < -1000 ) {
		wristPosition = -200;
		moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);
	}

	//Return claw, arm and wrist to starting position first and stacker last so that it can't get caught on anything
	armPosition = 0;
	wristPosition = 0;
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);


}
*/

/*
void 	moveToNeutralPosition() {

	//	Position for being able to Drive and clear block height
	int powerLevel = 75, armPosition = 0, wristPosition = 0, clawPosition = CLAW_NEUTRAL;


	//if the wrist if fully extended then get that next. It will hit the ground otherwise.
	if (wristPosition < -1000 ) {
		wristPosition = -200;
		moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);
	}


	//Return claw, arm and wrist to starting position first and stacker last so that it can't get caught on anything
	armPosition = 0;
	wristPosition = 0;
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);

}
*/

/*
void 	moveToStackDrivingPosition() {

	//	Position for being able to Drive and clear block height
	int powerLevel = 75, armPosition = ARM_DRIVING_STACK, wristPosition = 0, clawPosition = CLAW_NEUTRAL;

	wristPosition = getMotorEncoder(wristMotor);
	clawPosition = getMotorEncoder(clawMotor);
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);

}
*/

/*
void 	moveToStackAimingPosition() {

	//	Position for being able to Drive and clear block height
	int powerLevel = 75, armPosition = ARM_AIMING_STACK, wristPosition = 0, clawPosition = CLAW_NEUTRAL;

	wristPosition = getMotorEncoder(wristMotor);
	clawPosition = getMotorEncoder(clawMotor);
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);

}
*/

/*
void unloadBlocks() {

	int powerLevel = 35, armPosition = ARM_UNLOAD_STACK, wristPosition, clawPosition;

	wristPosition = getMotorEncoder(wristMotor);
	clawPosition = getMotorEncoder(clawMotor);

	//Move arm into position first
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);


	//Drive forward to leave the stack "free standing"
	float mmToDrive = 25.4 * STACK_CLEARANCE_DISTANCE;
	int speed = 25;
	driveStraight( mmToDrive, speed);

	//Return our mechanism to neutral to get more blocks
	moveToNeutralPosition();

}
*/


/*
void  putBlocksDown(){


	int powerLevel = 75, armPosition, wristPosition, clawPosition;


	armPosition = getMotorEncoder(armMotor);
	clawPosition = getMotorEncoder(clawMotor);

	//Return my wrist to a position to put the blocks down
	wristPosition = WRIST_GRABBING;
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);

	//move the arm down
	armPosition = ARM_GRABBING;
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);


	//Release the blocks
	clawPosition = CLAW_WHEEL_LIMIT;
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);


	//move the arm to neutral
	armPosition = 0;
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);


	//Let the driver decide what to do next. there must have been a mistake if we are putting blocks down
	//	float mmToDrive = (25.4 * BLOCK_CLEARANCE_DISTANCE);
	//	int speed = 25;
	//	driveStraight( mmToDrive, speed);

	globalBlocksInClaw = false;
}
*/

/*
void grabBlocks() {

	int powerLevel = 75, armPosition = 0, wristPosition = 0, clawPosition = CLAW_NEUTRAL;

	//first move our claw in tighter so it doesn't hit the wheels
	clawPosition = CLAW_WHEEL_LIMIT;
	moveMechanism( clawPosition, wristPosition, armPosition, 35);

	//move the arm down
	armPosition = ARM_GRABBING;
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);

	//move the wrist down
	wristPosition = WRIST_GRABBING;
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);

	//Grab blocks
	clawPosition = CLAW_GRABBING;
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);


}
*/

/*
void 	liftBlocksUp() {

	int powerLevel = 75, armPosition = 0, wristPosition = 0, clawPosition = CLAW_NEUTRAL;

	//first move our claw in tighter so it doesn't hit the wheels
	clawPosition = CLAW_WHEEL_LIMIT;
	wristPosition = WRIST_GRABBING;
	clawPosition = CLAW_GRABBING;

	//Pull back to clear blocks nearby (Clearance distance is in inches)
	float mmToDrive = -(25.4 * BLOCK_CLEARANCE_DISTANCE );
	int speed = 25;
	driveStraight( mmToDrive, speed);


	//Lift The blocks up a little
	armPosition = -150;
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);

	//Move the arm to allow us to show the blocks
	armPosition = ARM_LIFTING;
	wristPosition = WRIST_LIFTING;
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);

	globalBlocksInClaw = true;
}
*/

/*
void 	loadBlocks() {

	int powerLevel = 75, armPosition = ARM_LIFTING, wristPosition = WRIST_LIFTING, clawPosition = CLAW_GRABBING; // 44;

	//finish extending the wrist and getting ready to load
	armPosition = ARM_LOADING;
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);

	//Move the wrist into position after the stack is open because the block could be in the claw wrong and over-extend
	wristPosition = WRIST_LOADING;
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);

	//release the blocks
	clawPosition = CLAW_LOADING;
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);

	//wait for the blocks to slide down the stacker
	wait1Msec(1000);

	wait1Msec(100);

	//Get the wrist in neutral position
	wristPosition = 0;
	armPosition = ARM_DRIVING_STACK;
	clawPosition = CLAW_GRABBING;
	moveMechanism( clawPosition, wristPosition, armPosition, powerLevel);

	//Finish getting to neutral position
	moveToNeutralPosition();

	//return to where we were next to blocks nearby )
	float mmToDrive = 25.4 * BLOCK_CLEARANCE_DISTANCE;
	int speed = 25;
	driveStraight( mmToDrive, speed);

	globalBlocksInClaw = false;

}*/
