#pragma config(Motor,   motor1,        wristMotor,    tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,   motor2,        rightMotor,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Sensor,  port5,  			 gyro,          sensorVexIQ_Gyro)
#pragma config(Motor,   motor6,        leftMotor,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,   motor7,        armMotor,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,   motor12,       clawMotor,     tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Function Prototypes
void moveToAimingPosition();
void moveToNeutralPosition();
void moveToLowerStackingPosition();
void moveToUpperStackingPosition();
task displayMyMotorPositions();
void driveStraightForward();
void driveStraightBackward();

//Global Variable & Constant declarations

int const REVERSE_GRIP_ARM = 955, REVERSE_GRIP_WRIST = 460;

int const STACK_BLOCKS_LOW_WRIST = 250, 	STACK_BLOCKS_LOW_ARM = 40;

int const STACK_BLOCKS_HIGH_WRIST = 152, 	STACK_BLOCKS_HIGH_ARM = 243;

int const ARM_UPPER_LIMIT = 970, ARM_LOWER_LIMIT = 0;

int const WRIST_UPPER_LIMIT = 528, WRIST_LOWER_LIMIT = -17;

float globalClawPosition, globalArmPosition, globalWristPosition;

bool driveForwardPressed = false, driveBackwardPressed = false;


void moveToAimingPosition(){

	int armPowerLevel = 60;
	setMotorTarget(armMotor,  	 REVERSE_GRIP_ARM, 		armPowerLevel);
	setMotorTarget(wristMotor,   REVERSE_GRIP_WRIST , 	armPowerLevel);
}

void moveToNeutralPosition(){

	int armPowerLevel = 60;
	setMotorTarget(armMotor,  	 0, 		armPowerLevel);
	setMotorTarget(wristMotor,   0, 	armPowerLevel);
}

void moveToLowerStackingPosition(){
	int armPowerLevel = 60;
	setMotorTarget(armMotor,  	 STACK_BLOCKS_LOW_ARM, 		armPowerLevel);
	setMotorTarget(wristMotor,   STACK_BLOCKS_LOW_WRIST, 	armPowerLevel);
}

void moveToUpperStackingPosition(){
	int armPowerLevel = 60;
	setMotorTarget(armMotor,  	 STACK_BLOCKS_HIGH_ARM, 		armPowerLevel);
	setMotorTarget(wristMotor,   STACK_BLOCKS_HIGH_WRIST, 	armPowerLevel);
}

task main() {

	int leftMotorSpeed, rightMotorSpeed, wristMotorSpeed, armMotorSpeed, stickAValue, stickBValue, stickCValue, stickDValue;

	resetMotorEncoder(armMotor);
	resetMotorEncoder(clawMotor);
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(wristMotor);

	resetGyro(gyro);
	startGyroCalibration(gyro, gyroCalibrateSamples2048);
	eraseDisplay();
	getGyroCalibrationFlag(gyro);
	displayString(3, "calibrating gyro");
	wait1Msec(500);
	eraseDisplay();

	startTask(displayMyMotorPositions);


	while (true ){


		/***************************************************************************************************************/
		//Joystick Control:

		/***************************************************************************************************************/
		//Driving:

		if(getJoystickValue(BtnEUp) > 0)   {  //Drive Straight Forward
			driveStraightForward();
		}
		else if(getJoystickValue(BtnEDown) > 0)   {  //Drive Straight Backward
			driveStraightBackward();
		}
		else {
			driveForwardPressed = false;
			driveBackwardPressed = false;

			stickAValue  = getJoystickValue(ChA);
			if ((stickAValue <= 15) && (stickAValue >= -15) ) stickAValue = 0;

			stickBValue  = getJoystickValue(ChB);
			if ((stickBValue <= 15) && (stickBValue >= -15) ) stickBValue = 0;

			if (stickBValue >=0 ) 	 	stickBValue = (stickBValue / 10) * (stickBValue / 10) * 2;
			else stickBValue = 		- (stickBValue / 10) * (stickBValue / 10) * 2;



			leftMotorSpeed = stickAValue - stickBValue;
			rightMotorSpeed = stickAValue + stickBValue;

			if ( leftMotorSpeed > 100) leftMotorSpeed = 100;
			if ( leftMotorSpeed < -100) leftMotorSpeed = -100;

			if ( rightMotorSpeed > 100) rightMotorSpeed = 100;
			if ( rightMotorSpeed < -100) rightMotorSpeed = -100;

			if (leftMotorSpeed >=0 ) 	 	leftMotorSpeed = (leftMotorSpeed / 10) * (leftMotorSpeed / 10);
			else leftMotorSpeed = 		- (leftMotorSpeed / 10) * (leftMotorSpeed / 10);
			if (rightMotorSpeed >=0 ) 	rightMotorSpeed = (rightMotorSpeed / 10) * (rightMotorSpeed / 10);
			else rightMotorSpeed = 		- (rightMotorSpeed / 10) * (rightMotorSpeed / 10);

			setMotorSpeed(leftMotor, leftMotorSpeed);
			setMotorSpeed(rightMotor, rightMotorSpeed);
		}

		/***************************************************************************************************************/
		//WRIST MOTOR
		stickDValue		= getJoystickValue(ChD);
		if ((stickDValue <= 15) && (stickDValue >= -15) ) stickDValue = 0;

		wristMotorSpeed = stickDValue;

		if (wristMotorSpeed >=0 ) 	 	wristMotorSpeed = (wristMotorSpeed / 10) * (wristMotorSpeed / 10);
		else wristMotorSpeed = 		- (wristMotorSpeed / 10) * (wristMotorSpeed / 10);

		globalWristPosition = getMotorEncoder(wristMotor);

		if ((wristMotorSpeed > 0) && (globalWristPosition >= WRIST_UPPER_LIMIT)){
			setMotorTarget(wristMotor, WRIST_UPPER_LIMIT, 70);
		}
		else if ((wristMotorSpeed < 0) && (globalWristPosition <= WRIST_LOWER_LIMIT)) {
			setMotorTarget(wristMotor, WRIST_LOWER_LIMIT, 70);
		}
		else {
			//slow things down if we are near the limit of wrist movement
			if ( abs(globalWristPosition - WRIST_LOWER_LIMIT) < 10) {
				wristMotorSpeed = wristMotorSpeed / 4;
			}
			if ( abs(globalWristPosition - WRIST_UPPER_LIMIT) < 10) {
				wristMotorSpeed = wristMotorSpeed / 4;
			}
			setMotorSpeed(wristMotor, wristMotorSpeed );
		}

		/***************************************************************************************************************/
		//ARM MOTOR
		stickCValue		= getJoystickValue(ChC);
		if ((stickCValue <= 15) && (stickCValue >= -15) ) stickCValue = 0;

		armMotorSpeed = stickCValue;

		if (armMotorSpeed >=0 ) 	 	armMotorSpeed = (armMotorSpeed / 10) * (armMotorSpeed / 10);
		else armMotorSpeed = 		- (armMotorSpeed / 10) * (armMotorSpeed / 10);

		globalArmPosition = getMotorEncoder(armMotor);

		if ((armMotorSpeed > 0) && (globalArmPosition >= ARM_UPPER_LIMIT)){
			setMotorTarget(armMotor, ARM_UPPER_LIMIT, 70);
		}
		else if ((armMotorSpeed < 0) && (globalArmPosition <= ARM_LOWER_LIMIT)) {
			setMotorTarget(armMotor, ARM_LOWER_LIMIT, 70);
		}
		else {
			//slow things down if we are near the limit of arm movement
			if ( abs(globalArmPosition - ARM_LOWER_LIMIT) < 10){
				armMotorSpeed= armMotorSpeed/ 4;
			}
			if ( abs(globalArmPosition - ARM_UPPER_LIMIT) < 10){
				armMotorSpeed= armMotorSpeed/ 4;
			}
			setMotorSpeed(armMotor, armMotorSpeed);
		}


		/***************************************************************************************************************/
		//CLAW MOTOR
		if(getJoystickValue(BtnLUp) > 0)   {  //CLOSE
			setMotorSpeed(clawMotor, 70);
		}
		else if(getJoystickValue(BtnLDown) > 0)   {  //OPEN
			globalClawPosition = getMotorEncoder(clawMotor);
			if (globalClawPosition <= -87) {
				setMotorTarget(clawMotor, -87, 70);
			}
			else {
				setMotorSpeed(clawMotor, -70);
			}
		}
		else {
			globalClawPosition = getMotorEncoder(clawMotor);
			setMotorTarget(clawMotor, globalClawPosition, 90);
		}


		/***************************************************************************************************************/
		//Buttons to move our Arm for Us quickly to other positions
		if(getJoystickValue(BtnFUp) > 0)   {  //UP
			moveToAimingPosition();
		}
		if(getJoystickValue(BtnFDown) > 0)   {  //GRAB a Block
			moveToNeutralPosition();
		}

		/***************************************************************************************************************/
		//Block Stacking Positions
		//Buttons to move our Arm for Us quickly to other positions
		if(getJoystickValue(BtnRUp) > 0)   {  //Upper Stacking Position
			moveToUpperStackingPosition();
		}
		if(getJoystickValue(BtnRDown) > 0)   {  //Lower Stacking Position
			moveToLowerStackingPosition();
		}
		wait1Msec(50);   // Give actions time to make progress and prevent over-control from taking inputs too fast

	}

}


task displayMyMotorPositions(){

	float clawEncoderValue, wristEncoderValue, armEncoderValue, calibratedGyroDegrees, calibratedGyroHeading;



	while(true) {

		calibratedGyroDegrees = getGyroDegreesFloat(gyro);
		calibratedGyroHeading = getGyroHeadingFloat(gyro);

		clawEncoderValue 		= getMotorEncoder(clawMotor);
		wristEncoderValue 	= getMotorEncoder(wristMotor);
		armEncoderValue 		= getMotorEncoder(armMotor);

		eraseDisplay();
		displayString(0, "claw:  %f3", clawEncoderValue);
		displayString(1, "wrist: %f3", wristEncoderValue);
		displayString(2, "arm:   %f3", armEncoderValue);
		displayString(4, "d: %f3  h: %f3", calibratedGyroDegrees, calibratedGyroHeading);

		wait1Msec(1000);
	}
}



void driveStraightForward(){

	long 		timeIn1mSec;
	float 	leftMotorValue, rightMotorValue, drivePowerLevel_F, currentPowerLevel_F;
	int			drivePowerLevel, currentPowerLevel;

	driveBackwardPressed = false;

	if (!driveForwardPressed) {
		clearTimer(T1);
		driveForwardPressed = true;
		resetMotorEncoder(leftMotor);
		resetMotorEncoder(rightMotor);
	}

	leftMotorValue 		= getMotorEncoder(leftMotor);
	rightMotorValue 	= getMotorEncoder(rightMotor);

	drivePowerLevel = 100;
	drivePowerLevel_F =  (float) drivePowerLevel;
	timeIn1mSec = time1(T1);
	if 			( timeIn1mSec <  50) currentPowerLevel_F = drivePowerLevel_F / 4.0;
	else if ( timeIn1mSec < 100) currentPowerLevel_F = drivePowerLevel_F / 2.0;
	else if ( timeIn1mSec < 150) currentPowerLevel_F = drivePowerLevel_F * (3 / 4);
	else currentPowerLevel_F = drivePowerLevel_F;

	currentPowerLevel = (int) currentPowerLevel_F;

	if ( (abs(leftMotorValue) - 3) > abs(rightMotorValue) ) {
		setMotorSpeed(rightMotor, currentPowerLevel);
		currentPowerLevel = (int) ( currentPowerLevel_F * .94);
		setMotorSpeed(leftMotor, currentPowerLevel);

	}
	else if ( (abs(rightMotorValue) - 3) > abs(rightMotorValue) ) {
		setMotorSpeed(leftMotor, currentPowerLevel);
		currentPowerLevel = (int) ( currentPowerLevel_F * .94);
		setMotorSpeed(rightMotor, currentPowerLevel);
	}
	else {
		setMotorSpeed(leftMotor, currentPowerLevel);
		setMotorSpeed(rightMotor, currentPowerLevel);
	}


}

void driveStraightBackward(){

	long 		timeIn1mSec;
	float 	leftMotorValue, rightMotorValue, drivePowerLevel_F, currentPowerLevel_F;
	int			drivePowerLevel, currentPowerLevel;

	driveForwardPressed = false;

	if (!driveBackwardPressed) {
		clearTimer(T1);
		driveBackwardPressed = true;
		resetMotorEncoder(leftMotor);
		resetMotorEncoder(rightMotor);
	}

	leftMotorValue 		= getMotorEncoder(leftMotor);
	rightMotorValue 	= getMotorEncoder(rightMotor);

	drivePowerLevel = -100;
	drivePowerLevel_F =  (float) drivePowerLevel;
	timeIn1mSec = time1(T1);
	if 			( timeIn1mSec <  50) currentPowerLevel_F = drivePowerLevel_F / 4.0;
	else if ( timeIn1mSec < 100) currentPowerLevel_F = drivePowerLevel_F / 2.0;
	else if ( timeIn1mSec < 150) currentPowerLevel_F = drivePowerLevel_F * (3 / 4);
	else currentPowerLevel_F = drivePowerLevel_F;

	currentPowerLevel = (int) currentPowerLevel_F;

	if ( (abs(leftMotorValue) - 3) > abs(rightMotorValue) ) {
		setMotorSpeed(rightMotor, currentPowerLevel);
		currentPowerLevel = (int) ( currentPowerLevel_F * .94);
		setMotorSpeed(leftMotor, currentPowerLevel);

	}
	else if ( (abs(rightMotorValue) - 3) > abs(rightMotorValue) ) {
		setMotorSpeed(leftMotor, currentPowerLevel);
		currentPowerLevel = (int) ( currentPowerLevel_F * .94);
		setMotorSpeed(rightMotor, currentPowerLevel);
	}
	else {
		setMotorSpeed(leftMotor, currentPowerLevel);
		setMotorSpeed(rightMotor, currentPowerLevel);
	}

}
